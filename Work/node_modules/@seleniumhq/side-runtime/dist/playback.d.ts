/// <reference types="node" />
import EventEmitter from 'events';
import { Fn } from '@seleniumhq/side-commons';
import { PlaybackTree } from './playback-tree';
import Callstack, { Caller } from './callstack';
import Variables from './variables';
import { WebDriverExecutor } from '.';
import { CommandShape, TestShape } from '@seleniumhq/side-model';
import { CommandNode, CommandType } from './playback-tree/command-node';
declare const EE = "event-emitter";
declare const state = "state";
export interface PlaybackConstructorArgs {
    baseUrl: string;
    executor: WebDriverExecutor;
    getTestByName: (name: string) => TestShape;
    logger: Console;
    options?: Partial<PlaybackConstructorOptions>;
    variables: Variables;
}
export interface PlaybackConstructorOptions {
    pauseOnExceptions: boolean;
    ignoreBreakpoints: boolean;
    delay: number;
}
export interface ExtendedEventEmitter extends EventEmitter {
    emitCommandStateChange: (state: PlaybackEventShapes['COMMAND_STATE_CHANGED']) => void;
    emitControlFlowChange: (state: PlaybackEventShapes['CONTROL_FLOW_CHANGED']) => void;
}
export declare type RunningPromise = Promise<any>;
export declare type VaguePromise = (v?: unknown) => void;
export declare type VaguePromiseWrapper = {
    res: VaguePromise;
    rej: VaguePromise;
};
export interface PlayOptions {
    pauseImmediately?: boolean;
    startingCommandIndex?: number;
}
export declare type PlayTo = VaguePromiseWrapper & {
    command: string;
};
export default class Playback {
    constructor({ baseUrl, executor, getTestByName, logger, options, variables, }: PlaybackConstructorArgs);
    baseUrl: string;
    executor: WebDriverExecutor;
    getTestByName: PlaybackConstructorArgs['getTestByName'];
    logger: Console;
    options: PlaybackConstructorOptions;
    variables: Variables;
    [state]: {
        aborting: boolean;
        callstack?: Callstack;
        exitCondition?: keyof typeof PlaybackStatesPriorities;
        initialized: boolean;
        isPlaying: boolean;
        lastSentCommandState?: PlaybackEventShapes['COMMAND_STATE_CHANGED'];
        pausing: boolean;
        pausingResolve?: (v?: unknown) => void;
        playPromise?: RunningPromise;
        playTo?: PlayTo;
        resumeResolve?: VaguePromise;
        steps?: number;
        stepPromise?: VaguePromiseWrapper;
        stopping: boolean;
    };
    [EE]: ExtendedEventEmitter;
    initialized?: boolean;
    commands?: CommandShape[];
    playbackTree?: PlaybackTree;
    currentExecutingNode?: CommandNode;
    init(): Promise<void>;
    play(test: TestShape, { pauseImmediately, startingCommandIndex }?: PlayOptions): Promise<() => RunningPromise | undefined>;
    playTo(test: TestShape, stopIndex: number, startIndex: number): Promise<() => RunningPromise | undefined>;
    playFrom(test: TestShape, commandToStart: CommandShape): Promise<() => RunningPromise | undefined>;
    playSingleCommand(command: CommandShape): Promise<void>;
    step(steps?: number): Promise<void>;
    pause({ graceful }?: {
        graceful: boolean;
    }): Promise<void>;
    resume(): void;
    stop(): Promise<void>;
    abort(): Promise<void>;
    cleanup(): Promise<void>;
    _prepareToPlay(): Promise<void>;
    _beforePlay(): Promise<void>;
    _play(): Promise<() => RunningPromise | undefined>;
    _resume(): void;
    _executionLoop({ ignoreBreakpoint }?: {
        ignoreBreakpoint: boolean;
    }): Promise<void>;
    _playSingleCommand(command: CommandShape): Promise<void>;
    _executeCommand(commandNode: CommandNode): Promise<{
        next: Fn | CommandNode | undefined;
        skipped: boolean | undefined;
    }>;
    _run(testName: string): Promise<void>;
    _finishPlaying(): Promise<void>;
    _pause(): Promise<void>;
    _break(): Promise<void>;
    __pause(): Promise<void>;
    _handleException(unhandledBahaviorFn: Fn): Promise<any>;
    _delay(): Promise<void>;
    _unwind(): void;
    _setExitCondition(condition: keyof typeof PlaybackStatesPriorities): void;
}
export interface PlaybackEventShapes {
    COMMAND_STATE_CHANGED: {
        id: string;
        callstackIndex?: number;
        command: CommandShape;
        state: typeof CommandStates[keyof typeof CommandStates];
        message?: string;
        error?: Error;
    };
    PLAYBACK_STATE_CHANGED: {
        state: typeof PlaybackStates[keyof typeof PlaybackStates];
    };
    CALL_STACK_CHANGED: {
        change: typeof CallstackChange[keyof typeof CallstackChange];
        callee: TestShape;
        caller: Caller;
    };
    CONTROL_FLOW_CHANGED: {
        commandId: string;
        type: typeof CommandType[];
        end: boolean;
    };
}
export declare const PlaybackEvents: {
    readonly COMMAND_STATE_CHANGED: "command-state-changed";
    readonly PLAYBACK_STATE_CHANGED: "playback-state-changed";
    readonly CALL_STACK_CHANGED: "call-stack-changed";
    readonly CONTROL_FLOW_CHANGED: "control-flow-changed";
};
export declare const PlaybackStates: {
    readonly PREPARATION: "prep";
    readonly PLAYING: "playing";
    readonly FINISHED: "finished";
    readonly FAILED: "failed";
    readonly ERRORED: "errored";
    readonly PAUSED: "paused";
    readonly BREAKPOINT: "breakpoint";
    readonly STOPPED: "stopped";
    readonly ABORTED: "aborted";
};
export declare type PlaybackState = typeof PlaybackStates[keyof typeof PlaybackStates];
declare const PlaybackStatesPriorities: {
    readonly finished: 0;
    readonly failed: 1;
    readonly errored: 2;
    readonly stopped: 3;
    readonly aborted: 4;
};
export declare const CommandStates: {
    readonly EXECUTING: "executing";
    readonly PENDING: "pending";
    readonly SKIPPED: "skipped";
    readonly PASSED: "passed";
    readonly UNDETERMINED: "undetermined";
    readonly FAILED: "failed";
    readonly ERRORED: "errored";
};
export declare type CommandState = typeof CommandStates[keyof typeof CommandStates];
export declare const CallstackChange: {
    readonly CALLED: "called";
    readonly UNWINDED: "unwinded";
};
export {};
//# sourceMappingURL=playback.d.ts.map