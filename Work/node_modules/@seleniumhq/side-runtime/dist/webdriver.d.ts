import webdriver, { Capabilities, Condition as ConditionShape, WebDriver, WebElement as WebElementShape, WebElementCondition as WebElementConditionShape } from 'selenium-webdriver';
import Variables from './variables';
import { Fn } from '@seleniumhq/side-commons';
import { CommandShape } from '@seleniumhq/side-model';
import { PluginShape } from './types';
export declare type ExpandedCapabilities = Partial<Capabilities> & {
    browserName: string;
    'goog:chromeOptions'?: Record<string, boolean | number | string | string[]>;
};
declare const state: unique symbol;
/**
 * This is a polyfill type to allow for unsupported electron
 * driver methods to override with their own custom implementations
 */
export interface WindowAPI {
    setWindowSize: (executor: WebDriverExecutor, width: number, height: number) => Promise<void>;
}
export interface WebDriverExecutorConstructorArgs {
    capabilities?: ExpandedCapabilities;
    customCommands?: PluginShape['commands'];
    disableCodeExportCompat?: boolean;
    driver?: WebDriver;
    hooks?: WebDriverExecutorHooks;
    implicitWait?: number;
    server?: string;
    windowAPI?: WindowAPI;
}
export interface WebDriverExecutorInitOptions {
    baseUrl: string;
    logger: Console;
    variables: Variables;
}
export interface WebDriverExecutorCondEvalResult {
    value: boolean;
}
export interface BeforePlayHookInput {
    driver: WebDriverExecutor;
}
export interface CommandHookInput {
    command: CommandShape;
}
export interface StoreWindowHandleHookInput {
    windowHandle: string;
    windowHandleName: string;
}
export interface WindowAppearedHookInput {
    command: CommandShape;
    windowHandleName: CommandShape['windowHandleName'];
    windowHandle?: string | Error;
}
export interface WindowSwitchedHookInput {
    windowHandle?: string | Error;
}
export interface WebDriverExecutorHooks {
    onBeforePlay?: (input: BeforePlayHookInput) => Promise<void> | void;
    onAfterCommand?: (input: CommandHookInput) => Promise<void> | void;
    onBeforeCommand?: (input: CommandHookInput) => Promise<void> | void;
    onStoreWindowHandle?: (input?: StoreWindowHandleHookInput) => Promise<void> | void;
    onWindowAppeared?: (input: WindowAppearedHookInput) => Promise<void> | void;
    onWindowSwitched?: (input: WindowSwitchedHookInput) => Promise<void> | void;
}
export interface ElementEditableScriptResult {
    enabled: boolean;
    readonly: boolean;
}
export interface ScriptShape {
    script: string;
    argv: any[];
}
export default class WebDriverExecutor {
    constructor({ customCommands, disableCodeExportCompat, driver, capabilities, server, hooks, implicitWait, windowAPI, }: WebDriverExecutorConstructorArgs);
    baseUrl?: string;
    variables: Variables;
    cancellable?: {
        cancel: () => void;
    };
    capabilities?: ExpandedCapabilities;
    customCommands: Required<PluginShape>['commands'];
    disableCodeExportCompat: boolean;
    driver: WebDriver;
    server?: string;
    windowAPI: WindowAPI;
    windowHandle?: string;
    hooks: WebDriverExecutorHooks;
    implicitWait: number;
    initialized: boolean;
    logger?: Console;
    [state]?: any;
    init({ baseUrl, logger, variables }: WebDriverExecutorInitOptions): Promise<void>;
    cancel(): Promise<void>;
    cleanup(): Promise<void>;
    isAlive(): boolean;
    name(command: string): string;
    executeHook<T extends keyof WebDriverExecutorHooks>(hook: T, ...args: Parameters<NonNullable<WebDriverExecutorHooks[T]>>): Promise<void>;
    beforeCommand(commandObject: CommandShape): Promise<void>;
    afterCommand(commandObject: CommandShape): Promise<void>;
    waitForNewWindow(timeout?: number): Promise<string | Error | undefined>;
    registerCommand(commandName: string, fn: Fn): void;
    skip(): Promise<void>;
    doOpen(url: string): Promise<void>;
    doSetWindowSize(widthXheight: string): Promise<void>;
    doSelectWindow(handleLocator: string): Promise<void>;
    doClose(): Promise<void>;
    doSelectFrame(locator: string): Promise<void>;
    doSubmit(): Promise<void>;
    doAddSelection(locator: string, optionLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doRemoveSelection(locator: string, optionLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doCheck(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doUncheck(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doClick(locator: string, _: string): Promise<void>;
    doClickAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDoubleClick(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDoubleClickAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDragAndDropToObject(dragLocator: string, dropLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseDown(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseDownAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseMoveAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseOut(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseOver(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseUp(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseUpAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doSelect(locator: string, optionLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doEditContent(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doType(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doSendKeys(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doWaitForElementEditable(locator: string, timeout: string): Promise<void>;
    doWaitForElementNotEditable(locator: string, timeout: string): Promise<void>;
    doWaitForElementPresent(locator: string, timeout: string): Promise<void>;
    doWaitForElementNotPresent(locator: string, timeout: string): Promise<void>;
    doWaitForElementVisible(locator: string, timeout: string): Promise<void>;
    doWaitForElementNotVisible(locator: string, timeout: string): Promise<void>;
    doWaitForText(locator: string, text: string): Promise<void>;
    doRunScript(script: ScriptShape): Promise<void>;
    doExecuteScript(script: ScriptShape, optionalVariable?: string): Promise<void>;
    doExecuteAsyncScript(script: ScriptShape, optionalVariable?: string): Promise<void>;
    doAcceptAlert(): Promise<void>;
    doAcceptConfirmation(): Promise<void>;
    doAnswerPrompt(optAnswer?: string): Promise<void>;
    doDismissConfirmation(): Promise<void>;
    doDismissPrompt(): Promise<void>;
    doStore(string: string, variable: string): Promise<void>;
    doStoreAttribute(attributeLocator: string, variable: string): Promise<void>;
    doStoreElementCount(locator: string, variable: string): Promise<void>;
    doStoreJson(json: string, variable: string): Promise<void>;
    doStoreText(locator: string, variable: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doStoreTitle(variable: string): Promise<void>;
    doStoreValue(locator: string, variable: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doStoreWindowHandle(variable: string): Promise<void>;
    doAssert(variableName: string, value: string): Promise<void>;
    doAssertAlert(expectedText: string): Promise<void>;
    doAssertConfirmation(expectedText: string): Promise<void>;
    doAssertEditable(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotEditable(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertPrompt(expectedText: string): Promise<void>;
    doAssertTitle(title: string): Promise<void>;
    doAssertElementPresent(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertElementNotPresent(locator: string): Promise<void>;
    doAssertText(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotText(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertChecked(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotChecked(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertSelectedValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotSelectedValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertSelectedLabel(locator: string, label: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotSelectedLabel(locator: string, label: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDebugger(): Promise<void>;
    doEcho(string: string): Promise<void>;
    doPause(time: number): Promise<void>;
    doRun(): Promise<void>;
    doSetSpeed(): Promise<void>;
    evaluateConditional(script: ScriptShape): Promise<WebDriverExecutorCondEvalResult>;
    waitForElement(locator: string, fallback?: [string, string][]): Promise<WebElementShape>;
    isElementEditable(element: WebElementShape): Promise<boolean>;
    retryToAllowForIntermittency(locator: string, timeout: number): Promise<webdriver.WebElement>;
    waitForElementVisible(locator: string, timeout: number): Promise<webdriver.WebElement>;
    waitForText(locator: string, text: string): Promise<void>;
    wait<T extends any>(condition: Promise<T> | ConditionShape<T> | WebElementConditionShape, timeout?: number, message?: string, pollTimeout?: number): Promise<T | Error>;
}
export {};
//# sourceMappingURL=webdriver.d.ts.map