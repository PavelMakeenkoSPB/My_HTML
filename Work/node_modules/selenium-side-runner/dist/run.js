"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const side_runtime_1 = require("@seleniumhq/side-runtime");
const versioner_1 = __importDefault(require("./versioner"));
const buildRunners = ({ configuration, logger }) => {
    const runTest = async (project, test) => {
        logger.info(`Running test ${test.name}`);
        const pluginPaths = (0, side_runtime_1.correctPluginPaths)(project.path, project.plugins);
        const plugins = await (0, side_runtime_1.loadPlugins)(pluginPaths);
        const customCommands = (0, side_runtime_1.getCustomCommands)(plugins);
        const driver = new side_runtime_1.WebDriverExecutor({
            capabilities: configuration.capabilities,
            customCommands,
            hooks: {
                onBeforePlay: async () => {
                    await Promise.all(plugins.map((plugin) => {
                        const onBeforePlay = plugin.hooks?.onBeforePlay;
                        if (onBeforePlay) {
                            return onBeforePlay({ driver });
                        }
                    }));
                },
            },
            implicitWait: configuration.timeout,
            server: configuration.server,
        });
        await playbackUntilComplete();
        function playbackUntilComplete() {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise(async (resolve, reject) => {
                const playback = new side_runtime_1.Playback({
                    baseUrl: configuration.baseUrl || project.url,
                    executor: driver,
                    getTestByName: (name) => project.tests.find((t) => t.name === name),
                    logger,
                    variables: new side_runtime_1.Variables(),
                });
                const onComplete = async (failure) => {
                    await playback.cleanup();
                    await driver.cleanup();
                    if (failure) {
                        return reject(failure);
                    }
                    else {
                        return resolve(null);
                    }
                };
                const EE = playback['event-emitter'];
                EE.addListener(side_runtime_1.PlaybackEvents.PLAYBACK_STATE_CHANGED, ({ state }) => {
                    logger.debug(`Playing state changed ${state} for test ${test.name}`);
                    switch (state) {
                        case 'aborted':
                        case 'errored':
                        case 'failed':
                        case 'finished':
                        case 'paused':
                        case 'stopped':
                            logger.info(`Finished test ${test.name} ${state === 'finished' ? 'Success' : 'Failure'}`);
                            if (state !== 'finished') {
                                return onComplete(playback['state'].lastSentCommandState?.error ||
                                    new Error('Unknown error'));
                            }
                            return onComplete(null);
                    }
                    return;
                });
                EE.addListener(side_runtime_1.PlaybackEvents.COMMAND_STATE_CHANGED, ({ command, message, state, }) => {
                    const cmd = command;
                    const niceString = [cmd.command, cmd.target, cmd.value]
                        .filter((v) => !!v)
                        .join('|');
                    logger.debug(`${state} ${niceString}`);
                    if (message) {
                        logger.error(message);
                    }
                });
                try {
                    await playback.play(test, {
                        startingCommandIndex: 0,
                    });
                }
                catch (e) {
                    await playback.cleanup();
                    return reject(e);
                }
            });
        }
    };
    const runSuite = async (project, suite) => {
        logger.info(`Running suite ${suite.name}`);
        if (!suite.tests.length) {
            throw new Error(`The suite ${suite.name} has no tests, add tests to the suite using the IDE.`);
        }
        for (let i = 0, ii = suite.tests.length; i != ii; i++) {
            await runTest(project, project.tests.find((t) => t.id === suite.tests[i]));
        }
        logger.info(`Finished suite ${suite.name}`);
    };
    const runProject = async (project) => {
        logger.info(`Running project ${project.name}`);
        if (!configuration.force) {
            let warning = (0, versioner_1.default)(project.version, '2.0');
            if (warning) {
                logger.warn(warning);
            }
        }
        else {
            logger.warn("--force is set, ignoring project's version");
        }
        if (!project.suites.length) {
            throw new Error(`The project ${project.name} has no test suites defined, create a suite using the IDE.`);
        }
        for (let i = 0, ii = project.suites.length; i != ii; i++) {
            await runSuite(project, project.suites[i]);
        }
        logger.info(`Finished project ${project.name}`);
    };
    const runAll = async (projects) => {
        for (let i = 0, ii = projects.length; i != ii; i++) {
            await runProject(projects[i]);
        }
    };
    return {
        all: runAll,
        project: runProject,
        suite: runSuite,
        test: runTest,
    };
};
exports.default = buildRunners;
//# sourceMappingURL=run.js.map